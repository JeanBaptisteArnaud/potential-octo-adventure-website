@phdthesis{Arna13a,
		Abstract = {Dynamically-typed object-oriented programming languages do not provide type information until runtime. Two of their main advantages are that they allow fast prototyping and integrating changes at runtime. The ability of dynamically-typed languages to support program changes at runtime and the lack of type information doom the classic security approaches to failure. Controlling references to single objects and to graphs of objects is essential to build secure systems. Existing approaches are commonly based on static type system and cannot be applied to dynamically-typed languages.This thesis argue that: In the context of dynamically-typed languages, reifying references, controlling behavior, and isolating state via such references, is a practical way to control references. This thesis makes five contributions: - We propose dynamic read-only objects (DRO) as one kind of adaptation of behavioral change at reference-level. - We generalize the DRO model to enable more generic behavioral changes. We extend the Pharo programming environment and language with Handles, that are first-class references with the ability to change the behavior of referenced objects. - We define Metahandle to offer flexibility and adaptability to controlled references. - We propose SHandle, an extension of the Handle model to isolate side effects at the level of references. - And finally, we formalize the Handles and SHandle models to represent and explain their semantics. As validation of our thesis we have implemented three approaches  relevant to securing system using our model. In addition, as proof of concept we extended the Pharo virtual machine to support Handles, Metahandles and SHandles.},
		Author = {Jean-Baptiste Arnaud},
		Hal-Id = {tel-00808419},
		Institution = {INRIA},
		Inriareport = {2013},
		Keywords = {security, dynamically-typed languages, reflection, language design, first class reference, object-oriented programming},
		School = {Universit\'e de Lille},
		Title = {Towards First Class References as a Security Infrastructure in Dynamically-Typed Languages},
		Type_Rapport = {PhD},
		Url = {http://rmod.lille.inria.fr/archives/phd/PhD-2013-Arnaud.pdf},
		Year = {2013},
		Bdsk-Url-1 = {http://rmod.lille.inria.fr/archives/phd/PhD-2013-Arnaud.pdf}}
		
@inproceedings{Arna10a,
  title = {Read-Only Execution for Dynamic Languages},
  author = {Jean-Baptiste Arnaud and Marcus Denker and St\'ephane Ducasse and Damien Pollet and Alexandre Bergel and  Mathieu Suen},
  booktitle = {Proceedings of the 48th International Conference Objects, Models, Components, Patterns (TOOLS-Europe'10)},
  year = {2010},
  annote = {internationalconference},
  keywords = {tools10  lse-pub marcusdenker},
  month = jun,
  inria = {RMOD},
  inriareport = {2010},
  x-editorial-board = {yes},
  x-proceedings = {yes},
  x-international-audience = {yes},
  x-country = {FR},
  x-language = {EN},
  address = {Malaga, Spain},
  url = {http://rmod.lille.inria.fr/archives/papers/Arna10a-Tools2010-ReadOnlyExecutionForDynamicLanguages.pdf},
  abstract = {Supporting read-only and side effect free execution has been the focus of a large body of work in the area of statically typed programming languages. Read-onlyness in dynamically typed languages is difficult to achieve because of the absence of a type checking phase and the support of an open-world assumption in which code can be constantly added and modified. To address this issue, we propose Dynamic Read-Only references (DRO) that provide a view on an object where this object and its object graph are protected from modification. The read- only view dynamically propagates to aggregated objects, without changing the object graph itself; it acts as a read-only view of complex data structures, without making them read-only globally. We implement dynamic read-only references by using smart object proxies that lazily propagate the read-only view, following the object graph and driven by control flow and applied them to realize side-effect free assertions.},
  hal-id = {inria-00498377 / 7a#ndah},
  misc = {25%},
  rate = {25%},
  hal = {http://hal.archives-ouvertes.fr/inria-00498377/fr/}
}

@article{Arna13b,
	Abstract = {Controlling object graphs and giving specific semantics to references (such as read-only, own- ership, scoped sharing) has been the focus of a large body of research in the context of static type systems. Controlling references to single objects and to graphs of objects is essential to be able to build more secure systems, but is notoriously hard to achieve in absence of static type systems. In this article we embrace this challenge by proposing a solution to the following question: What is the underlying mechanism that can support the definition of properties (such as revocable, read-only, lent) at the reference level in the absence of a static type system? We present handles: first class references that propagate behavioral change dynamically to the object subgraph during program execution. In this article we describe handles and show how handles support the implementation of read-only references and revocable references. Handles have been fully implemented by modifying an existing virtual machine and we report their costs.},
	Aeres = {},
	Aeresstatus = {},
	Annote = {internationaljournal},
	Author = {Jean-Baptiste Arnaud and St\'ephane Ducasse and Marcus Denker},
	Doi = {},
	Hal-Id = {},
	Impactfactor = {},
	Inria = {RMOD},
	Inriareport = {},
	Journal = {Science of Computer Programming},
	Keywords = {Security,Dynamic language,Firstclass references,Language design},
	Pages = {},
	Secondurl = {},
	Title = {Behavior-Propagating First Class References For Dynamically-Typed Languages (under minor revision)},
	Url = {},
	Volume = {},
	X-Editorial-Board = {},
	X-International-Audience = {},
	X-Proceedings = {},
	Year = {2013},
	Bdsk-Url-1 = {},
	Bdsk-Url-2 = {}}


@inproceedings{Casa11a,
	Abstract = {Smalltalk is a reflective system. It means that it is defined in itself in a causally connected way. Traditionally, Smalltalk systems evolved by modifying and cloning what is called an image (a chunk of memory containing all the objects at a given point in time). During the evolution of the system, objects representing it are modified. However, such an image modification and cloning poses several problems: (1) There is no operational machine-executable algorithm that allows one to build a system from scratch. A system object may be modified but it may be difficult to reproduce its exact state before the changes. Therefore it is difficult to get a reproducible process. (2) As a consequence, certain classes may not have been initialized since years. (3) Finally, since the system acts as a living system, it is not simple to evolve the kernel for introducing new abstractions without performing some kind of brain surgery on oneself. There is a need to have a step by step process to build Smalltalk kernels from scratch. In this paper, after an analysis of past and current practices to mutate or generate kernels, we describe a kernel bootstrap process step-by-step. First the illusion of the existence of a kernel is created via stubs objects. Second the classes and meta-classes hierarchy are generated. Code is compiled and finally information needed by the virtual machine and execution are generated and installed.},
	Address = {Bernal, Buenos Aires, Argentina},
	Aeres = {ACT},
	Aeresstatus = {aeres12},
	Annote = {internationalworkshop},
	Author = {Gwenael Casaccio and St\'ephane Ducasse and Luc Fabresse and Jean-Baptiste Arnaud and van Ryseghem, Benjamin},
	Booktitle = {Proceedings of Smalltalks 2011 International Workshop},
	Hal-Id = {inria-00636785},
	Inria = {RMOD},
	Inriareport = {2011},
	Keywords = {pharo-pub lse-pub raweb2011 kzReflection},
	Labo = {dans},
	Selectif = {non},
	Title = {Bootstrapping a Smalltalk},
	Url = {http://rmod.lille.inria.fr/archives/workshops/Casa11a-Smalltalks-BootstrappingASmalltalk.pdf},
	X-Country = {FR},
	X-Editorial-Board = {yes},
	X-International-Audience = {yes},
	X-Language = {EN},
	X-Pays = {FR},
	X-Proceedings = {yes},
	Year = {2011}}